{
  "version": 3,
  "sources": ["../src/board.ts", "../src/moves.ts", "../src/interactiveBoard.ts", "../src/index.ts"],
  "sourcesContent": ["import { InteractiveBoard } from './interactiveBoard';\nimport { Move } from './moves';\nimport { Piece, Player, Tile } from './types';\n\nexport class Board {\n    pieces: Piece[];\n    constructor(board: Array<Piece>) {\n        this.pieces = board;\n    }\n\n    getPiece(x: number, y: number): Piece {\n        return this.pieces[x + y * 8];\n    }\n\n    setPiece(x: number, y: number, piece: Piece) {\n        this.pieces[x + y * 8] = piece;\n    }\n\n    getTileColor(x: number, y: number): Tile {\n        return (<Tile[]>['white', 'black'])[(x + y) % 2];\n    }\n\n    coordinates(): [number, number][] {\n        const coordinates: [number, number][] = [];\n\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                coordinates.push([x, y]);\n            }\n        }\n\n        return coordinates;\n    }\n\n    doMove(move: Move) {\n        const pieceToMove = this.getPiece(move.fromX, move.fromY);\n\n        this.setPiece(move.fromX, move.fromY, 'none');\n        this.setPiece(move.toX, move.toY, pieceToMove);\n    }\n\n    undoMove(move: Move) {\n        const pieceToMove = this.getPiece(move.toX, move.toY);\n        this.setPiece(move.fromX, move.fromY, pieceToMove);\n        this.setPiece(move.toX, move.toY, 'none');\n    }\n}\n\nexport const renderBoard = (board: InteractiveBoard, boardContainer: HTMLDivElement) => {\n    boardContainer.append(board.tilesElement, board.piecesElement);\n};\n", "import { Board } from './board';\nimport { Piece } from './types';\n\nexport interface Move {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n\n    /**\n     * This should include the start & finish\n     */\n    fullMovePath: [number, number][];\n}\n\nconst deduplicateMovesByStartEnd = (moves: Move[]) => {\n    const getMoveKey = (move: Move): string => {\n        // all of these are in the range [0, 7]. Would constructing a base-8 number be faster?\n        return `${move.fromX},${move.fromY},${move.toX},${move.toY}`;\n    };\n\n    const moveBuckets: { [key: string]: Move[] } = {};\n\n    for (const move of moves) {\n        const moveKey = getMoveKey(move);\n\n        if (moveKey in moveBuckets) {\n            moveBuckets[moveKey].push(move);\n        } else {\n            moveBuckets[moveKey] = [move];\n        }\n    }\n\n    const dedupMoves: Move[] = [];\n    // now, we only want one move per bucket\n    for (const moveKey in moveBuckets) {\n        // we want to keep the simplest move\n        const moveKeyMoves = moveBuckets[moveKey].sort(\n            (move1, move2) => move1.fullMovePath.length - move2.fullMovePath.length\n        );\n\n        dedupMoves.push(moveKeyMoves[0]);\n    }\n\n    return dedupMoves;\n};\n\nexport const generateAllMovesFromTile = (pieceX: number, pieceY: number, board: Board): Move[] => {\n    const moves = recursiveSearchMoves(\n        pieceX,\n        pieceY,\n        board,\n        {\n            fromX: pieceX,\n            fromY: pieceY,\n            toX: -1,\n            toY: -1,\n            fullMovePath: [[pieceX, pieceY]],\n        },\n        false\n    );\n\n    return deduplicateMovesByStartEnd(moves);\n};\n\nexport const generateAllMoves = (board: Board, pieceColor: Piece): Move[] => {\n    const moves: Move[] = [];\n\n    for (const coordinate of board.coordinates()) {\n        const tileOurColor = board.getPiece(coordinate[0], coordinate[1]) === pieceColor;\n        if (!tileOurColor) {\n            continue;\n        }\n\n        const tileMoves = generateAllMovesFromTile(coordinate[0], coordinate[1], board);\n        tileMoves.forEach((m) => moves.push(m));\n    }\n    return moves;\n};\n\nconst cloneMove = (move: Move): Move => {\n    return {\n        fromX: move.fromX,\n        fromY: move.fromY,\n        fullMovePath: [...move.fullMovePath],\n        toX: move.toX,\n        toY: move.toY,\n    };\n};\n\nconst recursiveSearchMoves = (\n    pieceX: number,\n    pieceY: number,\n    board: Board,\n    currentMoveData: Readonly<Move>,\n    hasJumped: boolean\n): Move[] => {\n    const validMoves: Move[] = [];\n\n    const tileOffsets: [number, number][] = [\n        [0, 1], //   N\n        [1, 1], //   NE\n        [1, 0], //   E\n        [1, -1], //  SE\n        [0, -1], //  S\n        [-1, -1], // SW\n        [-1, 0], //  W\n        [-1, 1], //  NW\n    ];\n\n    // can move in any of the 8 directions by one tile\n\n    for (const [offsetX, offsetY] of tileOffsets) {\n        // cannot move again after jumping\n        if (hasJumped) {\n            continue;\n        }\n\n        const newX = pieceX + offsetX;\n        const newY = pieceY + offsetY;\n\n        // check if the coordinate is valid\n        if (newX > 7 || newX < 0 || newY > 7 || newY < 0) {\n            continue;\n        }\n\n        // check if there is already a piece there\n        if (board.getPiece(newX, newY) !== 'none') {\n            continue;\n        }\n\n        // if there isn't, that's a valid move!\n\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.fullMovePath.push([newX, newY]);\n        newMove.toX = newX;\n        newMove.toY = newY;\n\n        validMoves.push(newMove);\n    }\n\n    // or alternatively, can move diagonally in each of the 8 directions\n    for (const [offsetX, offsetY] of tileOffsets) {\n        const newX = pieceX + offsetX * 2;\n        const newY = pieceY + offsetY * 2;\n\n        if (newX > 7 || newX < 0 || newY > 7 || newY < 0) {\n            continue;\n        }\n\n        // the coordinates we are jumping over\n        const jumpX = pieceX + offsetX;\n        const jumpY = pieceY + offsetY;\n\n        // check that the coordinates we are jumping over are actually occupied ...\n        const isSomeoneToJumpOver = board.getPiece(jumpX, jumpY) != 'none';\n\n        // ... and that the place we are jumping to is unoccupied ...\n        const isSomewhereToLand = board.getPiece(newX, newY) == 'none';\n\n        // ... and that we haven't already been there, to not jump back and forth\n        const hasBeenHereBefore = currentMoveData.fullMovePath.some(([moveX, moveY]) => {\n            return moveX == newX && moveY == newY;\n        });\n\n        if (!isSomeoneToJumpOver || !isSomewhereToLand || hasBeenHereBefore) {\n            continue;\n        }\n\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.fullMovePath.push([newX, newY]);\n\n        // and now, we can recursively search farther, since you can continue to jump\n        const deeperMoves = recursiveSearchMoves(newX, newY, board, newMove, true);\n\n        // and add all the new moves that we discovered to the list of moves\n        for (const move of deeperMoves) {\n            validMoves.push(move);\n        }\n    }\n\n    // or, can just stop here and settle down (if already moved)\n    if (hasJumped) {\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.toX = pieceX;\n        newMove.toY = pieceY;\n\n        validMoves.push(newMove);\n    }\n\n    return validMoves;\n};\n", "import { Board } from './board';\nimport { Move, generateAllMovesFromTile } from './moves';\nimport { Player, Piece, Tile, DIFFICULTY } from './types';\n\nexport class InteractiveBoard {\n    board: Board;\n    boardElement: HTMLElement;\n    selectedTileCoordinates: undefined | [number, number];\n    currentTurn: Player;\n    aiWorker: Worker;\n    tilesElement: HTMLDivElement;\n    piecesElement: HTMLDivElement;\n    difficulty: DIFFICULTY;\n    constructor(\n        boardElement: HTMLElement,\n        tileContainer: HTMLDivElement,\n        piecesContainer: HTMLDivElement\n    ) {\n        this.board = new Board(Array<Piece>(8 * 8).fill('none'));\n        this.currentTurn = 'white';\n        this.aiWorker = new Worker('./dist/worker.js');\n\n        this.boardElement = boardElement;\n        this.tilesElement = tileContainer;\n        this.piecesElement = piecesContainer;\n\n        this.difficulty = 'easy';\n\n        this.selectedTileCoordinates = undefined;\n\n        boardElement.addEventListener('click', (ev) => {\n            this.onClick(ev);\n        });\n\n        this.aiWorker.onmessage = (e) => {\n            this.receiveAiMove(e.data);\n        };\n\n        this._initializeTileElements();\n    }\n\n    _initializeTileElements() {\n        const tileContainers: HTMLDivElement[] = this.board.coordinates().map(([x, y]) => {\n            const tileContainer = document.createElement('div');\n            tileContainer.classList.add('tile');\n            tileContainer.classList.add(this.getTileColor(x, y));\n            tileContainer.dataset.selected = 'false';\n\n            return tileContainer;\n        });\n\n        this.tilesElement.append(...tileContainers);\n    }\n\n    loadFen(fen: string) {\n        const rows = fen.split('/');\n        let currentX = 0;\n        let currentY = 0;\n        for (const row of rows) {\n            for (const char of row) {\n                if (char === 'P') {\n                    this.setPiece(currentX, currentY, 'white');\n                    currentX++;\n                } else if (char === 'p') {\n                    this.setPiece(currentX, currentY, 'black');\n                    currentX++;\n                } else {\n                    currentX += parseInt(char);\n                }\n            }\n            currentX = 0;\n            currentY += 1;\n        }\n    }\n\n    getTileElement(x: number, y: number): HTMLDivElement {\n        const tileElements = Array.from(this.tilesElement.children) as HTMLDivElement[];\n\n        return tileElements[x + y * 8];\n    }\n\n    getPieceElement(x: number, y: number): HTMLDivElement {\n        const allPieces = Array.from(this.piecesElement.children) as HTMLDivElement[];\n\n        const pieceElement = allPieces.find(\n            (piece) => piece.dataset.x === x.toString() && piece.dataset.y === y.toString()\n        );\n\n        return pieceElement!;\n    }\n\n    setPiece(x: number, y: number, piece: Piece) {\n        if (this.board.getPiece(x, y) === 'none') {\n            // if the tile at (x, y) is empty, create a new piece element\n            this.board.setPiece(x, y, piece);\n\n            const pieceElement = document.createElement('div');\n            pieceElement.classList.add('piece');\n            pieceElement.dataset.pieceType = piece;\n            pieceElement.dataset.x = x.toString();\n            pieceElement.dataset.y = y.toString();\n            pieceElement.style.top = `calc(100%/8 * ${y} + (100%/8) * 0.10)`;\n            pieceElement.style.left = `calc(100%/8 * ${x} + (100%/8) * 0.10)`;\n            this.piecesElement.appendChild(pieceElement);\n        }\n        {\n            // otherwise, set an existing pieces coords\n            const pieceElement = this.getPieceElement(x, y);\n            pieceElement.dataset.pieceType = piece;\n        }\n    }\n\n    uiAnimateMove(move: Move) {\n        const { fromX, fromY, toX, toY } = move;\n        const pieceElement = this.getPieceElement(fromX, fromY);\n        pieceElement.dataset.x = toX.toString();\n        pieceElement.dataset.y = toY.toString();\n\n        for (let i = 1; i < move.fullMovePath.length; i++) {\n            const [x, y] = move.fullMovePath[i];\n            window.setTimeout(() => {\n                pieceElement.style.top = `calc(100%/8 * ${y} + (100%/8) * 0.10)`;\n                pieceElement.style.left = `calc(100%/8 * ${x} + (100%/8) * 0.10)`;\n            }, 500 * (i - 1));\n        }\n\n        pieceElement.style.zIndex = '1';\n        window.setTimeout(() => {\n            pieceElement.style.zIndex = '';\n        }, 500 * move.fullMovePath.length);\n    }\n\n    select(x: number, y: number) {\n        const tileElement = this.getTileElement(x, y);\n        tileElement.dataset.selected = 'true';\n    }\n\n    unselect(x: number, y: number) {\n        const tileElement = this.getTileElement(x, y);\n        tileElement.dataset.selected = 'false';\n    }\n\n    getTileColor(x: number, y: number): Tile {\n        return this.board.getTileColor(x, y);\n    }\n\n    addSuggestions(x: number, y: number) {\n        const allValidMoves = generateAllMovesFromTile(x, y, this.board);\n        for (const validMove of allValidMoves) {\n            const tileElement = this.getTileElement(validMove.toX, validMove.toY);\n            tileElement.classList.add('valid');\n        }\n    }\n\n    clearSuggestions() {\n        Array.from(document.querySelectorAll('.valid')).map((v) => v.classList.remove('valid'));\n    }\n\n    onClick(event: MouseEvent) {\n        const mouseX = event.offsetX;\n        const mouseY = event.offsetY;\n\n        const boardFractionX = mouseX / this.boardElement.getBoundingClientRect().width;\n        const boardFractionY = mouseY / this.boardElement.getBoundingClientRect().height;\n\n        const boardTileX = Math.floor(boardFractionX * 8);\n        const boardTileY = Math.floor(boardFractionY * 8);\n\n        this.onTileClick(boardTileX, boardTileY);\n    }\n\n    onTileClick(tileX: number, tileY: number) {\n        const prevSelectedCoords = this.selectedTileCoordinates;\n\n        if (prevSelectedCoords !== undefined) {\n            this.unselect(prevSelectedCoords[0], prevSelectedCoords[1]);\n            this.selectedTileCoordinates = undefined;\n\n            this.tryMove(prevSelectedCoords[0], prevSelectedCoords[1], tileX, tileY);\n        } else {\n            // if user had nothing selected and clicked on an empty tile, just do nothing\n            if (this.board.getPiece(tileX, tileY) === 'none') {\n                return;\n            }\n\n            this.selectedTileCoordinates = [tileX, tileY];\n            this.select(tileX, tileY);\n        }\n    }\n\n    removeMarks() {\n        Array.from(document.querySelectorAll('.mark')).map((v) => v.classList.remove('mark'));\n    }\n\n    markMove(move: Move) {\n        move.fullMovePath.forEach(([x, y]) => {\n            const tile = this.getTileElement(x, y);\n            tile.classList.add('mark');\n        });\n    }\n\n    initiateAiMove() {\n        this.aiWorker.postMessage([this.board.pieces, this.currentTurn, this.difficulty]);\n    }\n\n    receiveAiMove(move: Move | undefined) {\n        this.currentTurn = this.currentTurn === 'black' ? 'white' : 'black';\n\n        if (move === undefined) {\n            console.warn('AI has no response, probably end of game?');\n        } else {\n            this.doMove(move);\n            this.markMove(move);\n        }\n    }\n\n    doMove(move: Move) {\n        this.board.setPiece(move.toX, move.toY, this.board.getPiece(move.fromX, move.fromY));\n        this.board.setPiece(move.fromX, move.fromY, 'none');\n\n        this.uiAnimateMove(move);\n        this.removeMarks();\n    }\n\n    undoMove(move: Move) {\n        const pieceToMove = this.board.getPiece(move.toX, move.toY);\n        this.setPiece(move.fromX, move.fromY, pieceToMove);\n        this.setPiece(move.toX, move.toY, 'none');\n    }\n\n    tryMove(startX: number, startY: number, endX: number, endY: number) {\n        // only allow the player who has their turn right now to move\n        if (this.board.getPiece(startX, startY) !== this.currentTurn) {\n            return;\n        }\n\n        // if user clicks on a selected square, just de-select it\n        if (startX === endX && startY == endY) {\n            return;\n        }\n\n        // validate that this move actually exists\n        const allValidMoves = generateAllMovesFromTile(startX, startY, this.board);\n        const thisMove = allValidMoves.find((move) => {\n            return move.toX === endX && move.toY === endY;\n        });\n\n        if (thisMove === undefined) {\n            const errorAudio = new Audio('./audio/wood-sound-error.mp3');\n            errorAudio.play();\n            return;\n        }\n\n        this.doMove(thisMove);\n\n        // mark it as the other players turn now\n\n        this.currentTurn = this.currentTurn === 'black' ? 'white' : 'black';\n        // const moveAudio = new Audio('./audio/wood-sound.mp3');\n        // moveAudio.play();\n\n        window.setTimeout(() => {\n            this.initiateAiMove();\n        }, 1000);\n    }\n}\n", "import { renderBoard } from './board';\nimport { InteractiveBoard } from './interactiveBoard';\nimport { DIFFICULTY } from './types';\n\nconst main = async (mainElement: HTMLElement) => {\n    const boardContainer = document.createElement('div');\n    boardContainer.id = 'board-container';\n\n    mainElement.appendChild(boardContainer);\n\n    const tileContainer = document.createElement('div');\n    tileContainer.id = 'tiles';\n    const piecesContainer = document.createElement('div');\n    piecesContainer.id = 'pieces';\n\n    const board = new InteractiveBoard(boardContainer, tileContainer, piecesContainer);\n    // board.loadFen('4pppp/5ppp/6pp/7p/P/PP/PPP/PPPP');\n    board.loadFen('4PPPP/5PPP/6PP/7P/1p/pp/ppp/pppp');\n    renderBoard(board, boardContainer);\n\n    const easyButton = document.getElementById('easy') as HTMLButtonElement;\n    const mediumButton = document.getElementById('medium') as HTMLButtonElement;\n    const hardButton = document.getElementById('hard') as HTMLButtonElement;\n\n    easyButton.onclick = () => {\n        easyButton.dataset.selected = 'true';\n        mediumButton.dataset.selected = hardButton.dataset.selected = 'false';\n\n        board.difficulty = 'easy';\n        localStorage.setItem('difficulty', 'easy');\n    };\n    mediumButton.onclick = () => {\n        mediumButton.dataset.selected = 'true';\n        easyButton.dataset.selected = hardButton.dataset.selected = 'false';\n\n        board.difficulty = 'medium';\n        localStorage.setItem('difficulty', 'medium');\n    };\n    hardButton.onclick = () => {\n        hardButton.dataset.selected = 'true';\n        easyButton.dataset.selected = mediumButton.dataset.selected = 'false';\n\n        board.difficulty = 'hard';\n        localStorage.setItem('difficulty', 'hard');\n    };\n\n    board.difficulty = (localStorage.getItem('difficulty') as DIFFICULTY) || board.difficulty;\n\n    if (board.difficulty === 'easy') easyButton.dataset.selected = 'true';\n    if (board.difficulty === 'medium') mediumButton.dataset.selected = 'true';\n    if (board.difficulty === 'hard') hardButton.dataset.selected = 'true';\n};\n\nwindow.addEventListener('load', () => {\n    const mainElement = document.getElementsByTagName('main')[0];\n    main(mainElement);\n});\n"],
  "mappings": "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",
  "names": ["Board", "renderBoard", "init_board", "__esmMin", "board", "x", "y", "piece", "coordinates", "move", "pieceToMove", "boardContainer", "deduplicateMovesByStartEnd", "generateAllMovesFromTile", "cloneMove", "recursiveSearchMoves", "init_moves", "__esmMin", "moves", "getMoveKey", "move", "moveBuckets", "moveKey", "dedupMoves", "moveKeyMoves", "move1", "move2", "pieceX", "pieceY", "board", "currentMoveData", "hasJumped", "validMoves", "tileOffsets", "offsetX", "offsetY", "newX", "newY", "newMove", "jumpX", "jumpY", "isSomeoneToJumpOver", "isSomewhereToLand", "hasBeenHereBefore", "moveX", "moveY", "deeperMoves", "InteractiveBoard", "init_interactiveBoard", "__esmMin", "init_board", "init_moves", "boardElement", "tileContainer", "piecesContainer", "Board", "ev", "e", "tileContainers", "x", "y", "fen", "rows", "currentX", "currentY", "row", "char", "piece", "pieceElement", "move", "fromX", "fromY", "toX", "toY", "i", "tileElement", "allValidMoves", "generateAllMovesFromTile", "validMove", "v", "event", "mouseX", "mouseY", "boardFractionX", "boardFractionY", "boardTileX", "boardTileY", "tileX", "tileY", "prevSelectedCoords", "pieceToMove", "startX", "startY", "endX", "endY", "thisMove", "require_src", "__commonJSMin", "exports", "init_board", "init_interactiveBoard", "main", "mainElement", "__async", "boardContainer", "tileContainer", "piecesContainer", "board", "InteractiveBoard", "renderBoard", "easyButton", "mediumButton", "hardButton"]
}

{
  "version": 3,
  "sources": ["../src/moves.ts", "../src/ai.ts", "../src/board.ts", "../src/worker.ts"],
  "sourcesContent": ["import { Board } from './board';\nimport { Piece } from './types';\n\nexport interface Move {\n    fromX: number;\n    fromY: number;\n    toX: number;\n    toY: number;\n\n    /**\n     * This should include the start & finish\n     */\n    fullMovePath: [number, number][];\n}\n\nconst deduplicateMovesByStartEnd = (moves: Move[]) => {\n    const getMoveKey = (move: Move): string => {\n        // all of these are in the range [0, 7]. Would constructing a base-8 number be faster?\n        return `${move.fromX},${move.fromY},${move.toX},${move.toY}`;\n    };\n\n    const moveBuckets: { [key: string]: Move[] } = {};\n\n    for (const move of moves) {\n        const moveKey = getMoveKey(move);\n\n        if (moveKey in moveBuckets) {\n            moveBuckets[moveKey].push(move);\n        } else {\n            moveBuckets[moveKey] = [move];\n        }\n    }\n\n    const dedupMoves: Move[] = [];\n    // now, we only want one move per bucket\n    for (const moveKey in moveBuckets) {\n        // we want to keep the simplest move\n        const moveKeyMoves = moveBuckets[moveKey].sort(\n            (move1, move2) => move1.fullMovePath.length - move2.fullMovePath.length\n        );\n\n        dedupMoves.push(moveKeyMoves[0]);\n    }\n\n    return dedupMoves;\n};\n\nexport const generateAllMovesFromTile = (pieceX: number, pieceY: number, board: Board): Move[] => {\n    const moves = recursiveSearchMoves(\n        pieceX,\n        pieceY,\n        board,\n        {\n            fromX: pieceX,\n            fromY: pieceY,\n            toX: -1,\n            toY: -1,\n            fullMovePath: [[pieceX, pieceY]],\n        },\n        false\n    );\n\n    return deduplicateMovesByStartEnd(moves);\n};\n\nexport const generateAllMoves = (board: Board, pieceColor: Piece): Move[] => {\n    const moves: Move[] = [];\n\n    for (const coordinate of board.coordinates()) {\n        const tileOurColor = board.getPiece(coordinate[0], coordinate[1]) === pieceColor;\n        if (!tileOurColor) {\n            continue;\n        }\n\n        const tileMoves = generateAllMovesFromTile(coordinate[0], coordinate[1], board);\n        tileMoves.forEach((m) => moves.push(m));\n    }\n    return moves;\n};\n\nconst cloneMove = (move: Move): Move => {\n    return {\n        fromX: move.fromX,\n        fromY: move.fromY,\n        fullMovePath: [...move.fullMovePath],\n        toX: move.toX,\n        toY: move.toY,\n    };\n};\n\nconst recursiveSearchMoves = (\n    pieceX: number,\n    pieceY: number,\n    board: Board,\n    currentMoveData: Readonly<Move>,\n    hasJumped: boolean\n): Move[] => {\n    const validMoves: Move[] = [];\n\n    const tileOffsets: [number, number][] = [\n        [0, 1], //   N\n        [1, 1], //   NE\n        [1, 0], //   E\n        [1, -1], //  SE\n        [0, -1], //  S\n        [-1, -1], // SW\n        [-1, 0], //  W\n        [-1, 1], //  NW\n    ];\n\n    // can move in any of the 8 directions by one tile\n\n    for (const [offsetX, offsetY] of tileOffsets) {\n        // cannot move again after jumping\n        if (hasJumped) {\n            continue;\n        }\n\n        const newX = pieceX + offsetX;\n        const newY = pieceY + offsetY;\n\n        // check if the coordinate is valid\n        if (newX > 7 || newX < 0 || newY > 7 || newY < 0) {\n            continue;\n        }\n\n        // check if there is already a piece there\n        if (board.getPiece(newX, newY) !== 'none') {\n            continue;\n        }\n\n        // if there isn't, that's a valid move!\n\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.fullMovePath.push([newX, newY]);\n        newMove.toX = newX;\n        newMove.toY = newY;\n\n        validMoves.push(newMove);\n    }\n\n    // or alternatively, can move diagonally in each of the 8 directions\n    for (const [offsetX, offsetY] of tileOffsets) {\n        const newX = pieceX + offsetX * 2;\n        const newY = pieceY + offsetY * 2;\n\n        if (newX > 7 || newX < 0 || newY > 7 || newY < 0) {\n            continue;\n        }\n\n        // the coordinates we are jumping over\n        const jumpX = pieceX + offsetX;\n        const jumpY = pieceY + offsetY;\n\n        // check that the coordinates we are jumping over are actually occupied ...\n        const isSomeoneToJumpOver = board.getPiece(jumpX, jumpY) != 'none';\n\n        // ... and that the place we are jumping to is unoccupied ...\n        const isSomewhereToLand = board.getPiece(newX, newY) == 'none';\n\n        // ... and that we haven't already been there, to not jump back and forth\n        const hasBeenHereBefore = currentMoveData.fullMovePath.some(([moveX, moveY]) => {\n            return moveX == newX && moveY == newY;\n        });\n\n        if (!isSomeoneToJumpOver || !isSomewhereToLand || hasBeenHereBefore) {\n            continue;\n        }\n\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.fullMovePath.push([newX, newY]);\n\n        // and now, we can recursively search farther, since you can continue to jump\n        const deeperMoves = recursiveSearchMoves(newX, newY, board, newMove, true);\n\n        // and add all the new moves that we discovered to the list of moves\n        for (const move of deeperMoves) {\n            validMoves.push(move);\n        }\n    }\n\n    // or, can just stop here and settle down (if already moved)\n    if (hasJumped) {\n        const newMove: Move = cloneMove(currentMoveData);\n        newMove.toX = pieceX;\n        newMove.toY = pieceY;\n\n        validMoves.push(newMove);\n    }\n\n    return validMoves;\n};\n", "import { Board } from './board';\nimport { Move, generateAllMovesFromTile, generateAllMoves } from './moves';\nimport { DIFFICULTY, Piece, Player } from './types';\n\nexport const findMove = (\n    board: Board,\n    aiColor: Player,\n    difficulty: DIFFICULTY\n): Move | undefined => {\n    if (countPlayerScore(aiColor, board) === 980) {\n        return undefined;\n    }\n\n    const moveDepthSearch: number = {\n        easy: 0,\n        medium: 1,\n        hard: 2,\n    }[difficulty];\n\n    const myPieces = board.coordinates().filter(([x, y]) => board.getPiece(x, y) === aiColor);\n    let myPiecesMoves = myPieces.map(([x, y]) => generateAllMovesFromTile(x, y, board)).flat();\n    myPiecesMoves = orderMoves(myPiecesMoves, aiColor);\n\n    let bestMoves: Move[] = [];\n    let bestMoveScore = -Infinity;\n\n    const startTime = Date.now();\n\n    for (const move of myPiecesMoves) {\n        board.doMove(move);\n\n        let ourScore = 0;\n\n        const playerFinished = countPlayerScore(aiColor, board) === 980;\n        if (playerFinished) {\n            debugger;\n            ourScore = evaluate(board, aiColor);\n        } else {\n            // we just made a move, so now its time to evaluate from the perspective of the opponent\n\n            const opponentScore = recursiveBoardSearchAlphaBeta(\n                moveDepthSearch,\n                board,\n                aiColor === 'white' ? 'black' : 'white',\n                -Infinity,\n                Infinity\n            );\n\n            board.undoMove(move);\n            ourScore = -opponentScore;\n        }\n\n        console.log(ourScore, bestMoveScore);\n\n        if (ourScore > bestMoveScore) {\n            bestMoveScore = ourScore;\n            bestMoves = [move];\n        } else if (ourScore === bestMoveScore) {\n            bestMoves.push(move);\n        }\n    }\n\n    const endTime = Date.now();\n    console.log(`Took ${endTime - startTime}ms to evaluate positions (difficulty=${difficulty})`);\n    console.log(`Evaluated ${TIMES_TO_EVAL} position`);\n    TIMES_TO_EVAL = 0;\n\n    console.log(`Choosing one of ${bestMoves.length} options`);\n    return bestMoves[Math.floor(Math.random() * bestMoves.length)];\n};\n\n/**\n * Alpha beta pruning works by using really good moves to eliminate other possibilities, so if we evaluate (what we think)\n * are good moves first, it may allow alpha-beta to prune more effectively\n */\nconst orderMoves = (moves: Move[], playerToMove: Player) => {\n    return (\n        moves\n            .sort((moveA, moveB) => {\n                return evaluateMove(moveA, playerToMove) - evaluateMove(moveB, playerToMove);\n            })\n            // .sort sorts in ascending order, while we want the best moves first\n            .reverse()\n    );\n};\n\nlet TIMES_TO_EVAL = 0;\nconst evaluateMove = (move: Move, playerToMove: Player) => {\n    TIMES_TO_EVAL++;\n    const oppositeCornerX = playerToMove === 'black' ? 0 : 7;\n    const oppositeCornerY = playerToMove === 'white' ? 7 : 0;\n\n    const initialDistance =\n        Math.abs(move.fromX - oppositeCornerX) + Math.abs(move.fromY - oppositeCornerY);\n    const endingDistance =\n        Math.abs(move.toX - oppositeCornerX) + Math.abs(move.toY - oppositeCornerY);\n\n    // if a move is really good, the ending distance should probably be lower than the starting distance\n\n    const moveScore = initialDistance - endingDistance;\n\n    // if initialDistance-endingDistance > 0 (a good score) => initialDistance > endingDistance\n    // this is exactly what we want\n\n    return moveScore;\n};\n\nconst recursiveBoardSearchAlphaBeta = (\n    depth: number,\n    board: Board,\n    playerToMove: Player,\n    alpha: number,\n    beta: number\n): number => {\n    const playerFinished = countPlayerScore(playerToMove, board) === 980;\n    if (depth === 0 || playerFinished) {\n        return evaluate(board, playerToMove);\n    }\n\n    const moves: Move[] = generateAllMoves(board, playerToMove);\n\n    for (const move of moves) {\n        board.doMove(move);\n        const evaluation: number = -recursiveBoardSearchAlphaBeta(\n            depth - 1,\n            board,\n            playerToMove === 'black' ? 'white' : 'black',\n            -beta,\n            -alpha\n        );\n        board.undoMove(move);\n\n        if (evaluation >= beta) {\n            return beta;\n        }\n\n        alpha = Math.max(alpha, evaluation);\n    }\n    return alpha;\n};\n\n/**\n * Basic evaluation function.\n * Returns a:\n *  - positive value if the player who's turn it is to move is doing better\n *  - negative if the player who's turn it is to move is doing worse\n *  - 0 if it is a tie.\n */\nconst evaluate = (board: Board, playerToMove: Player) => {\n    const whiteScore = countPlayerScore('white', board);\n    const blackScore = countPlayerScore('black', board);\n\n    const evaluation = whiteScore - blackScore;\n    const perspective = playerToMove === 'white' ? 1 : -1;\n\n    return evaluation * perspective;\n};\n\nexport const countPlayerScore = (player: Piece, board: Board) => {\n    // count cumulative distances from the opposite corner\n\n    const oppositeCornerX = player === 'black' ? 0 : 7;\n    const oppositeCornerY = player === 'black' ? 7 : 0;\n\n    const myPieces = board.coordinates().filter(([x, y]) => board.getPiece(x, y) === player);\n    const myPiecesDistances = myPieces.map(\n        ([x, y]) => Math.abs(x - oppositeCornerX) + Math.abs(y - oppositeCornerY)\n    );\n\n    const cumulativeDistance = myPiecesDistances.reduce((a, b) => a + b, 0);\n    const score = 1000 - cumulativeDistance;\n\n    return score;\n};\n", "import { InteractiveBoard } from './interactiveBoard';\nimport { Move } from './moves';\nimport { Piece, Player, Tile } from './types';\n\nexport class Board {\n    pieces: Piece[];\n    constructor(board: Array<Piece>) {\n        this.pieces = board;\n    }\n\n    getPiece(x: number, y: number): Piece {\n        return this.pieces[x + y * 8];\n    }\n\n    setPiece(x: number, y: number, piece: Piece) {\n        this.pieces[x + y * 8] = piece;\n    }\n\n    getTileColor(x: number, y: number): Tile {\n        return (<Tile[]>['white', 'black'])[(x + y) % 2];\n    }\n\n    coordinates(): [number, number][] {\n        const coordinates: [number, number][] = [];\n\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                coordinates.push([x, y]);\n            }\n        }\n\n        return coordinates;\n    }\n\n    doMove(move: Move) {\n        const pieceToMove = this.getPiece(move.fromX, move.fromY);\n\n        this.setPiece(move.fromX, move.fromY, 'none');\n        this.setPiece(move.toX, move.toY, pieceToMove);\n    }\n\n    undoMove(move: Move) {\n        const pieceToMove = this.getPiece(move.toX, move.toY);\n        this.setPiece(move.fromX, move.fromY, pieceToMove);\n        this.setPiece(move.toX, move.toY, 'none');\n    }\n}\n\nexport const renderBoard = (board: InteractiveBoard, boardContainer: HTMLDivElement) => {\n    boardContainer.append(board.tilesElement, board.piecesElement);\n};\n", "import { findMove } from './ai';\nimport { Board } from './board';\n\nonmessage = (e) => {\n    const board = new Board(e.data[0]);\n    const move = findMove(board, e.data[1], e.data[2]);\n    postMessage(move);\n};\n"],
  "mappings": "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",
  "names": ["deduplicateMovesByStartEnd", "moves", "getMoveKey", "move", "moveBuckets", "moveKey", "dedupMoves", "moveKeyMoves", "move1", "move2", "generateAllMovesFromTile", "pieceX", "pieceY", "board", "recursiveSearchMoves", "generateAllMoves", "pieceColor", "coordinate", "m", "cloneMove", "currentMoveData", "hasJumped", "validMoves", "tileOffsets", "offsetX", "offsetY", "newX", "newY", "newMove", "jumpX", "jumpY", "isSomeoneToJumpOver", "isSomewhereToLand", "hasBeenHereBefore", "moveX", "moveY", "deeperMoves", "findMove", "board", "aiColor", "difficulty", "countPlayerScore", "moveDepthSearch", "myPiecesMoves", "x", "y", "generateAllMovesFromTile", "orderMoves", "bestMoves", "bestMoveScore", "startTime", "move", "ourScore", "evaluate", "opponentScore", "recursiveBoardSearchAlphaBeta", "endTime", "TIMES_TO_EVAL", "moves", "playerToMove", "moveA", "moveB", "evaluateMove", "oppositeCornerX", "oppositeCornerY", "initialDistance", "endingDistance", "depth", "alpha", "beta", "playerFinished", "generateAllMoves", "evaluation", "whiteScore", "blackScore", "player", "a", "b", "Board", "board", "x", "y", "piece", "coordinates", "move", "pieceToMove", "e", "board", "Board", "move", "findMove"]
}
